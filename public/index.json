[{"content":"查看 maxfiles 设置\nlaunchctl limit 设置一个较大的 maxfiles\nsudo launchctl limit maxfiles 102400 102400 查看应用资源情况\nlsof -n | awk \u0026#39;{print $1}\u0026#39; | uniq -c | sort -rn | head ","permalink":"http://wlchn.github.io/posts/mac-too-many-open-files/","summary":"查看 maxfiles 设置\nlaunchctl limit 设置一个较大的 maxfiles\nsudo launchctl limit maxfiles 102400 102400 查看应用资源情况\nlsof -n | awk \u0026#39;{print $1}\u0026#39; | uniq -c | sort -rn | head ","title":"Mac解决too-many-open-files问题"},{"content":"第一种方法 使用k8s.io/client-go/tools/cache\nfunc StartWatchingServices(c *Client) { watchlist := cache.NewListWatchFromClient( c.K8sClientset.CoreV1().RESTClient(), string(v1.ResourceServices), v1.NamespaceAll, fields.Everything(), ) _, controller := cache.NewInformer( watchlist, \u0026amp;v1.Service{}, 0, //Duration is int64 cache.ResourceEventHandlerFuncs{ AddFunc: func(obj interface{}) { fmt.Printf(\u0026#34;added: %s \\n\u0026#34;, obj) }, DeleteFunc: func(obj interface{}) { fmt.Printf(deleted: %s \\n\u0026#34;, obj) }, UpdateFunc: func(oldObj, newObj interface{}) { fmt.Printf(\u0026#34;changed \\n\u0026#34;) }, }, ) stop := make(chan struct{}) defer close(stop) go controller.Run(stop) for { time.Sleep(time.Second) } } 第二种方法 使用k8s.io/client-go/informers，可以 watch CRD 资源但需要使用 code-generator 生成 clientset 和 informer(指 CRD 资源)。\nfunc StartWatchingServices2(c *Client) { kubeInformerFactory := informers.NewSharedInformerFactory(c.K8sClientset, time.Second*30) svcInformer := kubeInformerFactory.Core().V1().Services().Informer() svcInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: func(obj interface{}) { fmt.Printf(\u0026#34;added: %s \\n\u0026#34;, obj) }, DeleteFunc: func(obj interface{}) { fmt.Printf(\u0026#34;deleted: %s \\n\u0026#34;, obj) }, UpdateFunc: func(oldObj, newObj interface{}) { fmt.Printf(\u0026#34;changed: %s \\n\u0026#34;, newObj) }, }) stop := make(chan struct{}) defer close(stop) kubeInformerFactory.Start(stop) for { time.Sleep(time.Second) } } 第三种方法 使用\truntimeCache \u0026quot;sigs.k8s.io/controller-runtime/pkg/cache\u0026quot;, 可以 watch CRD 资源，无需特殊处理。下例v1alpha1.Component是 CRD 资源。\nfunc StartWatchingComponents(c *Client) { informerCache, err := runtimeCache.New(c.RestConfig, runtimeCache.Options{}) if err != nil { panic(err) } informer, err := informerCache.GetInformer(\u0026amp;v1alpha1.Component{}) if err != nil { panic(err) } informer.AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: func(obj interface{}) { fmt.Printf(\u0026#34;added: %s \\n\u0026#34;, obj) }, DeleteFunc: func(obj interface{}) { fmt.Printf(\u0026#34;deleted: %s \\n\u0026#34;, obj) }, UpdateFunc: func(oldObj, newObj interface{}) { fmt.Printf(\u0026#34;changed: %s \\n\u0026#34;, newObj) }, }) stop := make(chan struct{}) defer close(stop) informerCache.Start(stop) // for { // time.Sleep(time.Second) // } } ","permalink":"http://wlchn.github.io/posts/kubernetes-watch-golang/","summary":"第一种方法 使用k8s.io/client-go/tools/cache\nfunc StartWatchingServices(c *Client) { watchlist := cache.NewListWatchFromClient( c.K8sClientset.CoreV1().RESTClient(), string(v1.ResourceServices), v1.NamespaceAll, fields.Everything(), ) _, controller := cache.NewInformer( watchlist, \u0026amp;v1.Service{}, 0, //Duration is int64 cache.ResourceEventHandlerFuncs{ AddFunc: func(obj interface{}) { fmt.Printf(\u0026#34;added: %s \\n\u0026#34;, obj) }, DeleteFunc: func(obj interface{}) { fmt.Printf(deleted: %s \\n\u0026#34;, obj) }, UpdateFunc: func(oldObj, newObj interface{}) { fmt.Printf(\u0026#34;changed \\n\u0026#34;) }, }, ) stop := make(chan struct{}) defer close(stop) go controller.Run(stop) for { time.Sleep(time.Second) } } 第二种方法 使用k8s.io/client-go/informers，可以 watch CRD 资源但需要使用 code-generator 生成 clientset 和 informer(指 CRD 资源)。","title":"Kubernetes-watch-golang实现"},{"content":"本文将详细介绍如何利用 Keycloak 配置 Kubernetes 登录验证，以及 RBAC 管理。 本文全部为测试环境工具。 流程示意 配置 Keycloak 安装配置 生产环境不建议使用 docker 直接部署 Keycloak。如果使用 nginx 需要将PROXY_ADDRESS_FORWARDING配置成true.\nsudo docker run -e KEYCLOAK_USER=wanglei -e KEYCLOAK_PASSWORD=your_password -e PROXY_ADDRESS_FORWARDING=true -p 8081:8080 -d jboss/keycloak 配置 nginx 将 server_name 配置成你的域名,代理 Keycloak 端口，注意上面PROXY_ADDRESS_FORWARDING=true\nserver { listen 80; server_name key.wanglei.me; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://localhost:8081; } } 在 Clients 中创建 kubernetes 设置Client ID为kubernetes，Client Protocol选择openid-connect即 OIDC 协议。 设置 Client 将Access Type设置为confidential, Valid Redirect URIs根据需要设置，本文后面用到 kubelogin,需要设置为http://localhost:8000 记录 Client Secret 在 Credentials 中找到 Secret，后面需要用到。 新建 Mapper 选择Mapper Type为User Attribute,选择Claim JSON Type为String,下面开关一律选on(可根据需求更改)。此处Token Claim Name字段设置为groups,后面配置 kube-apiserver 会用到。 为 User 添加 Attribute 添加 key groups, value admin,然后点击 add，再 save。 配置 kubernetes 此处使用 kind(kubernetes in docker) https://github.com/kubernetes-sigs/kind#installation-and-usage 为例。 安装 kind（mac 为例）\nbrew install kind 配置 kube-apiserver config.yaml\nkind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 kubeadmConfigPatches: - | kind: ClusterConfiguration metadata: name: config apiServer: extraArgs: oidc-issuer-url: \u0026#34;https://key.wanglei.me/auth/realms/master\u0026#34; oidc-client-id: \u0026#34;kubernetes\u0026#34; oidc-username-claim: \u0026#34;preferred_username\u0026#34; oidc-username-prefix: \u0026#34;-\u0026#34; oidc-groups-claim: \u0026#34;groups\u0026#34; 创建本地 kubernetes 集群。\nkind create cluster --config=./config.yaml 查看 apiserver log\nkubectl logs -n kube-system --tail=10 -f kube-apiserver-kind-control-plane 配置 RBAC RBAC 介绍https://kubernetes.io/docs/reference/access-authn-authz/rbac/\n创建一个 ClusterRoleBinding, 文中使用系统自带的 cluster-admin 为例，也可以创建符合要求的 role。 创建 cluster-role-binding.yaml\nkind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: keycloak-admin-group roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: Group name: admin apiGroup: rbac.authorization.k8s.io kubectl apply\nkubectl apply -f cluster-role-binding.yaml 配置 kubeconfig 安装 kubelogin，https://github.com/int128/kubelogin\nbrew install int128/kubelogin/kubelogin kubelogin 示意图 编辑 ~/.kube/config,里面为 kind 生成的配置，添加一个名为 oidc 的 user，并配置到 kind-kind 的 context\napiVersion: v1 clusters: - cluster: insecure-skip-tls-verify: true server: https://localhost:6443 name: docker-for-desktop-cluster - cluster: certificate-authority-data: ... server: https://127.0.0.1:32773 name: kind-kind contexts: - context: cluster: docker-for-desktop-cluster user: docker-for-desktop name: docker-for-desktop - context: cluster: kind-kind user: oidc name: kind-kind current-context: kind-kind kind: Config preferences: {} users: - name: docker-for-desktop user: client-certificate-data: ... client-key-data: ... - name: kind-kind user: client-certificate-data: ... client-key-data: ... - name: oidc user: auth-provider: config: client-id: kubernetes client-secret: your-secret idp-issuer-url: https://key.wanglei.me/auth/realms/master name: oidc 运行 kubelogin,出现如下提示即登录成功。 试一下 此时再看~/.kube/config,可以看到多了两行id-token和refresh-token\n- name: oidc user: auth-provider: config: client-id: kubernetes client-secret: 50cc10ed-1859-4042-9305-c913470ac6e2 id-token: ... idp-issuer-url: https://key.wanglei.me/auth/realms/master refresh-token: ... name: oidc 其中id-token可以解析为如下 json 同理，如需要多种权限验证皆可以通过 RBAC 和 Keycloak 很好的实现。 参考： https://kubernetes.io/docs/reference/access-authn-authz/authentication/ https://octopus.com/blog/kubernetes-oauth https://kind.sigs.k8s.io/docs/user/quick-start/#enable-feature-gates-in-your-cluster https://github.com/int128/kubelogin/blob/master/docs/setup.md#keycloak https://blog.hdls.me/15647317755993.html\n","permalink":"http://wlchn.github.io/posts/keycloak-kubernetes-sso-oidc-rbac/","summary":"本文将详细介绍如何利用 Keycloak 配置 Kubernetes 登录验证，以及 RBAC 管理。 本文全部为测试环境工具。 流程示意 配置 Keycloak 安装配置 生产环境不建议使用 docker 直接部署 Keycloak。如果使用 nginx 需要将PROXY_ADDRESS_FORWARDING配置成true.\nsudo docker run -e KEYCLOAK_USER=wanglei -e KEYCLOAK_PASSWORD=your_password -e PROXY_ADDRESS_FORWARDING=true -p 8081:8080 -d jboss/keycloak 配置 nginx 将 server_name 配置成你的域名,代理 Keycloak 端口，注意上面PROXY_ADDRESS_FORWARDING=true\nserver { listen 80; server_name key.wanglei.me; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://localhost:8081; } } 在 Clients 中创建 kubernetes 设置Client ID为kubernetes，Client Protocol选择openid-connect即 OIDC 协议。 设置 Client 将Access Type设置为confidential, Valid Redirect URIs根据需要设置，本文后面用到 kubelogin,需要设置为http://localhost:8000 记录 Client Secret 在 Credentials 中找到 Secret，后面需要用到。 新建 Mapper 选择Mapper Type为User Attribute,选择Claim JSON Type为String,下面开关一律选on(可根据需求更改)。此处Token Claim Name字段设置为groups,后面配置 kube-apiserver 会用到。 为 User 添加 Attribute 添加 key groups, value admin,然后点击 add，再 save。 配置 kubernetes 此处使用 kind(kubernetes in docker) https://github.","title":"利用Keycloak实现Kubernetes单点登录与权限验证（SSO,OIDC,RBAC）"},{"content":"由于 Golang 编译之后的文件是二进制，而 scratch 是 docker 最基础的空 image，所以可以使用 scratch 来构建 Go 程序的 docker image，使得最终构建的 image 最小化.\n构建 image 过程分为两步：\n在 Go 基础 image 中 build. 将 build 好的二进制文件拷贝到 scratch image 中。 无需 cgo 的程序 对于无需 cgo 交叉编译的程序，使用 scratch 来作为最终运行的基础 image 非常合适。\n首先，选择合适版本的 golang 基础 image 来 build，这里没有必要选择更小的 golang alpine，build 过程中 pull 一般会有缓存所以 pull 速度差别不大，此外 alpine 中没有 git 和 ssl，我们在构建 image 过程中都有可能用到，况且 alpine 也不会影响最终 image 大小。\nFROM golang:1.13 AS builder 禁掉 cgo 交叉编译，我们服务器一般为 linux amd64，build 二进制文件。\nRUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\u0026#34;-w -s\u0026#34; -o /bin/appmain main.go 对于绝大多数 go 程序而言，是无需 root 来运行，根据 docker best practice，使用 non-root 来运行程序能够带来更好的安全性，所以我们使用 non-root 用户来运行，创建一个 appuser，之后再拷贝到 scratch 运行 image 中。（scratch 是空 image，所以在 builder 中创建 user，再拷贝。）\n# 创建appuser RUN groupadd -r appuser \u0026amp;\u0026amp; useradd --no-log-init -r -g appuser appuser ... # 拷贝appuser到scratch COPY --from=builder /etc/passwd /etc/passwd ... # 选择appuser为默认程序运行用户 USER appuser 多数程序可能会用到 ssl，我们将 builder 中的 crt 拷贝一下即可。（如果 builder 是 alpine，不能拷贝，需要在 alpine 中 apk 先预装一下。）\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ 完整版 Dockerfile\nFROM golang:1.13 AS builder COPY . /app WORKDIR /app RUN groupadd -r appuser \u0026amp;\u0026amp; useradd --no-log-init -r -g appuser appuser RUN go mod download RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\u0026#34;-w -s\u0026#34; -o /bin/appmain main.go FROM scratch COPY --from=builder /etc/passwd /etc/passwd COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ COPY --from=builder /bin/appmain /bin/appmain USER appuser CMD [ \u0026#34;/bin/appmain\u0026#34; ] 需要 cgo 的程序 有些 Go 程序是需要 cgo 交叉编译的，例如 ethereum. 对于需要 cgo 的程序，相对于 scratch，更推荐使用 alpine 来作为基础 image，原因是 alpine 中带有 libc，并且体积也才 2MB 多。而 scratch 中没有，当然也可以在 builder 中 ldd 依赖并拷贝到 scratch 中。只是用 alpine 会更方便一些。\n在 alpine 中只要软链接一下就可以使用。\nRUN mkdir /lib64 \u0026amp;\u0026amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2 此外，创建 non-root 用户的步骤也没有必要在 builder 中进行了，可以直接在 alpine 中创建。\nRUN addgroup -S appuser \u0026amp;\u0026amp; adduser -S -G appuser appuser 完整版 Dockerfile\nFROM golang:1.13 AS builder COPY . /app WORKDIR /app RUN go mod download RUN CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build -ldflags=\u0026#34;-w -s\u0026#34; -o /bin/appmain main.go FROM alpine:3.10 RUN mkdir /lib64 \u0026amp;\u0026amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2 COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ COPY --from=builder /bin/appmain /bin/appmain RUN addgroup -S appuser \u0026amp;\u0026amp; adduser -S -G appuser appuser USER appuser CMD [ \u0026#34;/bin/appmain\u0026#34; ] ","permalink":"http://wlchn.github.io/posts/scratch-go-docker-image/","summary":"由于 Golang 编译之后的文件是二进制，而 scratch 是 docker 最基础的空 image，所以可以使用 scratch 来构建 Go 程序的 docker image，使得最终构建的 image 最小化.\n构建 image 过程分为两步：\n在 Go 基础 image 中 build. 将 build 好的二进制文件拷贝到 scratch image 中。 无需 cgo 的程序 对于无需 cgo 交叉编译的程序，使用 scratch 来作为最终运行的基础 image 非常合适。\n首先，选择合适版本的 golang 基础 image 来 build，这里没有必要选择更小的 golang alpine，build 过程中 pull 一般会有缓存所以 pull 速度差别不大，此外 alpine 中没有 git 和 ssl，我们在构建 image 过程中都有可能用到，况且 alpine 也不会影响最终 image 大小。\nFROM golang:1.13 AS builder 禁掉 cgo 交叉编译，我们服务器一般为 linux amd64，build 二进制文件。","title":"使用scratch构建最小化Go程序的docker-image"},{"content":"问题 两个不同的域名的 localStorage 不能直接互相访问。那么如何在aaa.com中如何调用bbb.com的 localStorage?\n实现原理 1.在aaa.com的页面中，在页面中嵌入一个 src 为bbb.com的iframe，此时这个iframe里可以调用bbb.com的 localStorage。 2.用postMessage方法实现页面与iframe之间的通信。 综合 1、2 便可以实现aaa.com中调用bbb.com的 localStorage。\n优化 iframe 我们可以在bbb.com中写一个专门负责共享 localStorage 的页面，例如叫做page1.html，这样可以防止无用的资源加载到iframe中。\n示例 以在aaa.com中读取bbb.com中的 localStorage 的item1为例，写同理： bbb.com中page1.html，监听aaa.com通过postMessage传来的信息，读取 localStorage，然后再使用postMessage方法传给aaa.com的接收者。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en-US\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.addEventListener(\u0026#39;message\u0026#39;, function(event) { if (event.origin === \u0026#39;https://aaa.com\u0026#39;) { const { key } = event.data; const value = localStorage.getItem(key); event.source.postMessage({wallets: wallets}, event.origin); } }, false); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; This page is for sharing localstorage. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在aaa.com的页面中加入一个 src 为bbb.com/page1.html隐藏的iframe。\n\u0026lt;iframe id=\u0026#34;bbb-iframe\u0026#34; src=\u0026#34;https://bbb.com/page1.html\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 在aaa.com的页面中加入下面 script 标签。在页面加载完毕时通过postMessage告诉iframe中监听者，读取item1。监听bbb.com传回的item1的值并输出。\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { const bbbIframe = document.getElementById(\u0026#39;bbb-iframe\u0026#39;); bbbIframe.contentWindow.postMessage({key: \u0026#39;item1\u0026#39;}, \u0026#39;https://bbb.com\u0026#39;); } window.addEventListener(\u0026#39;message\u0026#39;, function(event) { if (event.origin === \u0026#39;https://bbb.com\u0026#39;) { console.log(event.data); } }, false); \u0026lt;/script\u0026gt; ","permalink":"http://wlchn.github.io/posts/share-localstorage-sessionstorage/","summary":"问题 两个不同的域名的 localStorage 不能直接互相访问。那么如何在aaa.com中如何调用bbb.com的 localStorage?\n实现原理 1.在aaa.com的页面中，在页面中嵌入一个 src 为bbb.com的iframe，此时这个iframe里可以调用bbb.com的 localStorage。 2.用postMessage方法实现页面与iframe之间的通信。 综合 1、2 便可以实现aaa.com中调用bbb.com的 localStorage。\n优化 iframe 我们可以在bbb.com中写一个专门负责共享 localStorage 的页面，例如叫做page1.html，这样可以防止无用的资源加载到iframe中。\n示例 以在aaa.com中读取bbb.com中的 localStorage 的item1为例，写同理： bbb.com中page1.html，监听aaa.com通过postMessage传来的信息，读取 localStorage，然后再使用postMessage方法传给aaa.com的接收者。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en-US\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.addEventListener(\u0026#39;message\u0026#39;, function(event) { if (event.origin === \u0026#39;https://aaa.com\u0026#39;) { const { key } = event.data; const value = localStorage.getItem(key); event.source.postMessage({wallets: wallets}, event.origin); } }, false); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; This page is for sharing localstorage. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在aaa.com的页面中加入一个 src 为bbb.","title":"不同域名之间共享localStorage-sessionStorage"},{"content":"问题描述 三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目 Let\u0026rsquo;s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？\n答案 答案是会。不换门的话，赢得汽车的几率是 1/3。换门的话，赢得汽车的几率是 2/3。\n争议 有人认为，在主持人排除了一个门之后，汽车只可能在另外两个门中，所以在两扇门的概率各是 1/2。\n分析 首先参赛者选定了一扇门，主持人未开启门时，汽车在这扇门的概率为 1/3，在另外两扇门中的概率为 2/3，此时争议不大。而另外两扇门中必定至少有一扇是山羊，所以即使主持人指出这两扇门中一扇是山羊，并不会影响这两扇门的概率，两扇概率和仍为 2/3，此时一扇已知是山羊，所以两扇中的另外一扇是汽车的概率是 2/3。所以换门会提高概率。\n思考 如果主持人开启揭露一扇门是山羊后，另外一个人 B 此时在剩下的两扇门中做抉择，并且他不知道其他信息，只知道一扇是汽车，一扇是羊，那么此时 B 选择到汽车的概率是 1/2。 这是因为没有之前的信息，B 不知道那扇门概率大，B 此时是在两扇门中做随机选择，B 可能有 1/2 的概率选择 A(参赛者)开始选择的门，也有 1/2 的概率选择 A 将要换的门。所以 B 选择到汽车的概率为 1/2 _ 1/3 + 1/2 _ 2/3 = 1/2。\n程序模拟 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { totalTimes := 1000000 aRightTimes := 0 bRightTimes := 0 rand.Seed(time.Now().UnixNano()) for time := 1; time \u0026lt;= totalTimes; time++ { doors := [3]bool{false, false, false} doors[rand.Intn(3)] = true aFirstChoice := rand.Intn(3) var hostChoice, aChangedChoice int for i, door := range doors { if i != aFirstChoice \u0026amp;\u0026amp; !door { hostChoice = i } } for i, _ := range doors { if i != aFirstChoice \u0026amp;\u0026amp; i != hostChoice { aChangedChoice = i } } var bChoice int if rand.Intn(2) == 0 { bChoice = aFirstChoice } else { bChoice = aChangedChoice } if doors[aChangedChoice] { aRightTimes++ } if doors[bChoice] { bRightTimes++ } } fmt.Println(\u0026#34;totalTimes: \u0026#34;, totalTimes) fmt.Println(\u0026#34;aChangedChoice: \u0026#34;, aRightTimes) fmt.Println(\u0026#34;bChoice: \u0026#34;, bRightTimes) } 结果符合预期，A 换门后正确概率为 2/3，B 随机选择正确的概率为 1/2：\ntotalTimes: 1000000 aChangedChoice: 667407 bChoice: 499262 reference 问题描述引自百度百科\n","permalink":"http://wlchn.github.io/posts/three-doors-golang/","summary":"问题描述 三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目 Let\u0026rsquo;s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？\n答案 答案是会。不换门的话，赢得汽车的几率是 1/3。换门的话，赢得汽车的几率是 2/3。\n争议 有人认为，在主持人排除了一个门之后，汽车只可能在另外两个门中，所以在两扇门的概率各是 1/2。\n分析 首先参赛者选定了一扇门，主持人未开启门时，汽车在这扇门的概率为 1/3，在另外两扇门中的概率为 2/3，此时争议不大。而另外两扇门中必定至少有一扇是山羊，所以即使主持人指出这两扇门中一扇是山羊，并不会影响这两扇门的概率，两扇概率和仍为 2/3，此时一扇已知是山羊，所以两扇中的另外一扇是汽车的概率是 2/3。所以换门会提高概率。\n思考 如果主持人开启揭露一扇门是山羊后，另外一个人 B 此时在剩下的两扇门中做抉择，并且他不知道其他信息，只知道一扇是汽车，一扇是羊，那么此时 B 选择到汽车的概率是 1/2。 这是因为没有之前的信息，B 不知道那扇门概率大，B 此时是在两扇门中做随机选择，B 可能有 1/2 的概率选择 A(参赛者)开始选择的门，也有 1/2 的概率选择 A 将要换的门。所以 B 选择到汽车的概率为 1/2 _ 1/3 + 1/2 _ 2/3 = 1/2。\n程序模拟 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { totalTimes := 1000000 aRightTimes := 0 bRightTimes := 0 rand.","title":"三门问题（蒙提霍尔悖论）分析与Golang模拟"},{"content":"在无序数组中寻找中位数，最差复杂度为 O(n). 实现算法为 Median of medians，又叫 BFPRT 算法。 实现原理与复杂度研究：https://en.wikipedia.org/wiki/Median_of_medians\n贴一版 JS 实现：\nexport const selectMedian = (arr, compare) =\u0026gt; { return selectK(arr, Math.floor(arr.length / 2), compare); }; export const selectK = (arr, k, compare) =\u0026gt; { if (!Array.isArray(arr) || arr.length === 0 || arr.length - 1 \u0026lt; k) { return; } if (arr.length === 1) { return arr[0]; } let idx = selectIdx(arr, 0, arr.length - 1, k, compare || defaultCompare); return arr[idx]; }; const partition = (arr, left, right, pivot, compare) =\u0026gt; { let temp = arr[pivot]; arr[pivot] = arr[right]; arr[right] = temp; let track = left; for (let i = left; i \u0026lt; right; i++) { // if (arr[i] \u0026lt; arr[right]) { if (compare(arr[i], arr[right]) === -1) { let t = arr[i]; arr[i] = arr[track]; arr[track] = t; track++; } } temp = arr[track]; arr[track] = arr[right]; arr[right] = temp; return track; }; const selectIdx = (arr, left, right, k, compare) =\u0026gt; { if (left === right) { return left; } let dest = left + k; while (true) { let pivotIndex = right - left + 1 \u0026lt;= 5 ? Math.floor(Math.random() * (right - left + 1)) + left : medianOfMedians(arr, left, right, compare); pivotIndex = partition(arr, left, right, pivotIndex, compare); if (pivotIndex === dest) { return pivotIndex; } else if (pivotIndex \u0026lt; dest) { left = pivotIndex + 1; } else { right = pivotIndex - 1; } } }; const medianOfMedians = (arr, left, right, compare) =\u0026gt; { let numMedians = Math.ceil((right - left) / 5); for (let i = 0; i \u0026lt; numMedians; i++) { let subLeft = left + i * 5; let subRight = subLeft + 4; if (subRight \u0026gt; right) { subRight = right; } let medianIdx = selectIdx(arr, subLeft, subRight, Math.floor((subRight - subLeft) / 2), compare); let temp = arr[medianIdx]; arr[medianIdx] = arr[left + i]; arr[left + i] = temp; } return selectIdx(arr, left, left + numMedians - 1, Math.floor(numMedians / 2), compare); }; const defaultCompare = (a, b) =\u0026gt; { return a \u0026lt; b ? -1 : a \u0026gt; b ? 1 : 0; }; ","permalink":"http://wlchn.github.io/posts/median-of-medians-js/","summary":"在无序数组中寻找中位数，最差复杂度为 O(n). 实现算法为 Median of medians，又叫 BFPRT 算法。 实现原理与复杂度研究：https://en.wikipedia.org/wiki/Median_of_medians\n贴一版 JS 实现：\nexport const selectMedian = (arr, compare) =\u0026gt; { return selectK(arr, Math.floor(arr.length / 2), compare); }; export const selectK = (arr, k, compare) =\u0026gt; { if (!Array.isArray(arr) || arr.length === 0 || arr.length - 1 \u0026lt; k) { return; } if (arr.length === 1) { return arr[0]; } let idx = selectIdx(arr, 0, arr.length - 1, k, compare || defaultCompare); return arr[idx]; }; const partition = (arr, left, right, pivot, compare) =\u0026gt; { let temp = arr[pivot]; arr[pivot] = arr[right]; arr[right] = temp; let track = left; for (let i = left; i \u0026lt; right; i++) { // if (arr[i] \u0026lt; arr[right]) { if (compare(arr[i], arr[right]) === -1) { let t = arr[i]; arr[i] = arr[track]; arr[track] = t; track++; } } temp = arr[track]; arr[track] = arr[right]; arr[right] = temp; return track; }; const selectIdx = (arr, left, right, k, compare) =\u0026gt; { if (left === right) { return left; } let dest = left + k; while (true) { let pivotIndex = right - left + 1 \u0026lt;= 5 ?","title":"Median-of-medians无序数组寻找中位数最差O(n)复杂度JS实现"},{"content":"使用 create-react-app 创建的单页应用（SPA）是在 build 时注入环境变量的。一旦 build 成静态文件便不能动态提供环境变量了。 比如 build 一个单页应用的 docker image，可以在 build 时提供环境变量。但是已经 build 完成，使用 docker run 运行的时候不能再传递环境变量。 本文主要解决在运行时提供环境变量的问题。 原理：通过一段 shell 脚本将指定将 env 转换为 config.js 文件，该文件和 build 好的 static 文件 serve 在同一目录下，在应用中引用 config.js 文件，通过 window._env 获取环境变量。shell 脚本通过 docker image 的 entrypoint 执行。服务使用 go 构建的一个简单服务器，比 nginx 轻量很多。\n将如下env.sh文件拷问到项目目录下，在 entrypoint（docker run）时执行，作用是将环境变量转出 config.js #!/bin/sh if [ $CONFIG_VARS ]; then # clear echo -n \u0026gt; ${CONFIG_FILE_PATH}/config.js SPLIT=$(echo $CONFIG_VARS | tr \u0026#34;,\u0026#34; \u0026#34;\\n\u0026#34;) echo \u0026#34;window._env = {\u0026#34; \u0026gt;\u0026gt; ${CONFIG_FILE_PATH}/config.js for VAR in ${SPLIT}; do VALUE=$(printenv ${VAR}) echo \u0026#34; ${VAR}: \\\u0026#34;${VALUE}\\\u0026#34;,\u0026#34; \u0026gt;\u0026gt; ${CONFIG_FILE_PATH}/config.js done echo \u0026#34;}\u0026#34; \u0026gt;\u0026gt; ${CONFIG_FILE_PATH}/config.js fi # disable broswer cache sed -i \u0026#34;s/config.js?v=[0-9]*/config.js?v=$(date +\u0026#39;%s\u0026#39;)/g\u0026#34; /srv/http/index.html # for macOS # sed -i \u0026#34;\u0026#34; \u0026#34;s/config.js?v=[0-9]*/config.js?v=$(date +\u0026#39;%s\u0026#39;)/g\u0026#34; /srv/http/index.html # exec CMD exec \u0026#34;$@\u0026#34; 例如\n# 传入 CONFIG_VARS=ABC,XYZ ABC=helloabc XYZ=HELLOXYZ # 转换为 window._env = { ABC: \u0026#34;helloabc\u0026#34;, XYZ: \u0026#34;HELLOXYZ\u0026#34;, } 编写 Dockerfile，使用 goStatic 当做静态文件服务器（比 nginx 轻量）。build 完成只有几 MB. FROM node:11 AS builder COPY . /app WORKDIR /app RUN yarn install RUN yarn run build FROM wlchn/gostatic:latest ENV CONFIG_FILE_PATH /srv/http COPY --from=builder /app/build /srv/http COPY ./env.sh /env.sh # Ensure convert envs to window._env ENTRYPOINT [\u0026#34;sh\u0026#34;, \u0026#34;/env.sh\u0026#34;] # start server. listen on 8043(in container) by default. CMD [\u0026#34;/goStatic\u0026#34;] 在项目中引用 config.js \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/config.js?v=\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 使用环境变量，通过window._env获取 let _env = process.env; // check if there is env exits in local, otherwise using window._env if (_env.ENV_ABC) { _env = window._env; } // so you can use env like _env.ENV_ABC 转换示例 # pass envs like: CONFIG_VARS=ABC,XYZ ABC=helloabc XYZ=HELLOXYZ # you coud get config.js window._env = { ABC: \u0026#34;helloabc\u0026#34;, XYZ: \u0026#34;HELLOXYZ\u0026#34;, } # in your app, you can use like console.log(_env.ABC) console.log(_env.XYZ) GitHub https://github.com/wlchn/docker-spa-env reference https://github.com/SocialEngine/docker-nginx-spa https://medium.freecodecamp.org/how-to-implement-runtime-environment-variables-with-create-react-app-docker-and-nginx-7f9d42a91d70 ","permalink":"http://wlchn.github.io/posts/react-spa-runtime-docker-env/","summary":"使用 create-react-app 创建的单页应用（SPA）是在 build 时注入环境变量的。一旦 build 成静态文件便不能动态提供环境变量了。 比如 build 一个单页应用的 docker image，可以在 build 时提供环境变量。但是已经 build 完成，使用 docker run 运行的时候不能再传递环境变量。 本文主要解决在运行时提供环境变量的问题。 原理：通过一段 shell 脚本将指定将 env 转换为 config.js 文件，该文件和 build 好的 static 文件 serve 在同一目录下，在应用中引用 config.js 文件，通过 window._env 获取环境变量。shell 脚本通过 docker image 的 entrypoint 执行。服务使用 go 构建的一个简单服务器，比 nginx 轻量很多。\n将如下env.sh文件拷问到项目目录下，在 entrypoint（docker run）时执行，作用是将环境变量转出 config.js #!/bin/sh if [ $CONFIG_VARS ]; then # clear echo -n \u0026gt; ${CONFIG_FILE_PATH}/config.js SPLIT=$(echo $CONFIG_VARS | tr \u0026#34;,\u0026#34; \u0026#34;\\n\u0026#34;) echo \u0026#34;window.","title":"为React单页应用提供Runtime运行时环境变量"},{"content":"使用 kubectl apply 或者 create 命令创建/更新部署后，其 pod 需要时间完成创建/更新。 如果在 CI 中不等待所有 pod 更新完成，下一步流程很有可能使用更新前的环境。\n正确方法 kubectl rollout status 根据实际情况kubectl rollout status命令，能够正确的获取 rollout status。\nATTEMPTS=0 ROLLOUT_STATUS_CMD=\u0026#34;kubectl rollout status deployment/myapp -n namespace\u0026#34; until $ROLLOUT_STATUS_CMD || [ $ATTEMPTS -eq 60 ]; do $ROLLOUT_STATUS_CMD ATTEMPTS=$((attempts + 1)) sleep 10 done 以上 shell 脚本经过轮询kubectl rollout status可以很好的解决实际问题。\n错误方法 kubectl wait 注意kubectl wait命令不能适用于更新部署。\nkubectl wait --for=condition=available --timeout=600s deployment/myapp -n namespace 该命令只能判断 deployment 是否 available，不能用来判断 rollout，即 available 状态的 deployment，很可能老的 pod 还在 terminating，新的 pod 还没创建好。\nreferences https://kubernetes.io/docs/concepts/workloads/controllers/deployment/ https://www.jeffgeerling.com/blog/2018/updating-kubernetes-deployment-and-waiting-it-roll-out-shell-script ","permalink":"http://wlchn.github.io/posts/kubernetes-kubectl-wait-rollout/","summary":"使用 kubectl apply 或者 create 命令创建/更新部署后，其 pod 需要时间完成创建/更新。 如果在 CI 中不等待所有 pod 更新完成，下一步流程很有可能使用更新前的环境。\n正确方法 kubectl rollout status 根据实际情况kubectl rollout status命令，能够正确的获取 rollout status。\nATTEMPTS=0 ROLLOUT_STATUS_CMD=\u0026#34;kubectl rollout status deployment/myapp -n namespace\u0026#34; until $ROLLOUT_STATUS_CMD || [ $ATTEMPTS -eq 60 ]; do $ROLLOUT_STATUS_CMD ATTEMPTS=$((attempts + 1)) sleep 10 done 以上 shell 脚本经过轮询kubectl rollout status可以很好的解决实际问题。\n错误方法 kubectl wait 注意kubectl wait命令不能适用于更新部署。\nkubectl wait --for=condition=available --timeout=600s deployment/myapp -n namespace 该命令只能判断 deployment 是否 available，不能用来判断 rollout，即 available 状态的 deployment，很可能老的 pod 还在 terminating，新的 pod 还没创建好。","title":"Kubernetes等待部署完成-kubectl-wait-rollout"},{"content":"系列文章 Go WebAssembly 入门（一）\nGetting Started 编写 main.go\npackage main import ( \u0026#34;strconv\u0026#34; \u0026#34;syscall/js\u0026#34; ) // 传入value1, value2, result三个元素的id，将value1+value2结果赋给result元素 func add(ids []js.Value) { // 根据id获取输入值 value1 := js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, ids[0].String()).Get(\u0026#34;value\u0026#34;).String() value2 := js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, ids[1].String()).Get(\u0026#34;value\u0026#34;).String() int1, _ := strconv.Atoi(value1) int2, _ := strconv.Atoi(value2) // 将相加结果set给result元素 js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, ids[2].String()).Set(\u0026#34;value\u0026#34;, int1+int2) } // 添加监听事件 func registerCallbacks() { js.Global().Set(\u0026#34;add\u0026#34;, js.NewCallback(add)) } func main() { c := make(chan struct{}, 0) println(\u0026#34;Go WebAssembly Initialized!\u0026#34;) registerCallbacks() \u0026lt;-c } 将 main.go 编译成 lib.wasm\nGOOS=js GOARCH=wasm go build -o lib.wasm main.go 在 index.html 中调用 lib.wasm\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; if (!WebAssembly.instantiateStreaming) { // polyfill WebAssembly.instantiateStreaming = async (resp, importObject) =\u0026gt; { const source = await (await resp).arrayBuffer(); return await WebAssembly.instantiate(source, importObject); }; } const go = new Go(); let mod, inst; WebAssembly.instantiateStreaming(fetch(\u0026#34;lib.wasm\u0026#34;), go.importObject).then(async (result) =\u0026gt; { mod = result.module; inst = result.instance; await go.run(inst) }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;value1\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;value2\u0026#34;/\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;add\u0026#34; onClick=\u0026#34;add(\u0026#39;value1\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;result\u0026#39;);\u0026#34;\u0026gt;add\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;result\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打开 server，在浏览器打开即可调用 WebAssembly 二进制文件执行。\ngo run server.go 示例代码 GitHub https://github.com/wlchn/go-webassembly reference https://tutorialedge.net/golang/go-webassembly-tutorial/ ","permalink":"http://wlchn.github.io/posts/go-webassembly-tutorial-2/","summary":"系列文章 Go WebAssembly 入门（一）\nGetting Started 编写 main.go\npackage main import ( \u0026#34;strconv\u0026#34; \u0026#34;syscall/js\u0026#34; ) // 传入value1, value2, result三个元素的id，将value1+value2结果赋给result元素 func add(ids []js.Value) { // 根据id获取输入值 value1 := js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, ids[0].String()).Get(\u0026#34;value\u0026#34;).String() value2 := js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, ids[1].String()).Get(\u0026#34;value\u0026#34;).String() int1, _ := strconv.Atoi(value1) int2, _ := strconv.Atoi(value2) // 将相加结果set给result元素 js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, ids[2].String()).Set(\u0026#34;value\u0026#34;, int1+int2) } // 添加监听事件 func registerCallbacks() { js.Global().Set(\u0026#34;add\u0026#34;, js.NewCallback(add)) } func main() { c := make(chan struct{}, 0) println(\u0026#34;Go WebAssembly Initialized!\u0026#34;) registerCallbacks() \u0026lt;-c } 将 main.","title":"Go-WebAssembly-入门（二）"},{"content":"有关 WebAssembly 的介绍可以参考 几张图让你看懂 WebAssembly 简单来说 WebAssembly 就是将其他语言 C/Go/Rust 等语言编译成 wasm 可执行二进制文件，浏览器来执行 wasm。wasm 相比 JS,拥有体积更小，执行更快，因为最终编译成二进制文件，所以一些安全策略代码也更适合 wasm。 经过尝试 C 和 Go 分别编写 WebAssembly，相较而言我认为 Go 无论从语言层面还是工具链，用起来都更加方便一些。 本文使用原生 go build，生成的 wasm 文件大约在1.4M左右，在生产环境中这个体积是很大的，优化 go 的 wasm 体积可以使用 tinygo 来 build，同样的代码使用 tinygo 构建之后约为22K，甚至比 C 语言构建 wasm 的体积还要小（C 语言 build 后约为44K，不同版本不同环境可能略有差异）。参考https://tinygo.org/\n本文介绍 Go WebAssembly 入门，前提已经安装 Go 1.11 及以上版本。 系列文章 Go WebAssembly 入门（二）\nGetting Started 编辑 main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, Go WebAssembly!\u0026#34;) } 把 main.go build 成 WebAssembly(简写为 wasm)二进制文件\nGOOS=js GOARCH=wasm go build -o lib.wasm main.go 把 JavaScript 依赖拷贝到当前路径\ncp \u0026#34;$(go env GOROOT)/misc/wasm/wasm_exec.js\u0026#34; . 创建一个 index.html 文件，并引入 wasm_exec.js 文件，调用刚才 build 的 lib.wasm\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;lib.wasm\u0026#34;), go.importObject).then((result) =\u0026gt; { go.run(result.instance); }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 创建 server.go 监听 8080 端口，serve 当前路径\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) var ( listen = flag.String(\u0026#34;listen\u0026#34;, \u0026#34;:8080\u0026#34;, \u0026#34;listen address\u0026#34;) dir = flag.String(\u0026#34;dir\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;directory to serve\u0026#34;) ) func main() { flag.Parse() log.Printf(\u0026#34;listening on %q...\u0026#34;, *listen) err := http.ListenAndServe(*listen, http.FileServer(http.Dir(*dir))) log.Fatalln(err) } 启动服务\ngo run server.go 在浏览器访问 localhost:8080,打开浏览器 console，就可以看到输出Hello, Go WebAssembly!。\n系列文章 Go WebAssembly 入门（二）\nreference https://github.com/golang/go/wiki/WebAssembly ","permalink":"http://wlchn.github.io/posts/go-webassembly-tutorial-1/","summary":"有关 WebAssembly 的介绍可以参考 几张图让你看懂 WebAssembly 简单来说 WebAssembly 就是将其他语言 C/Go/Rust 等语言编译成 wasm 可执行二进制文件，浏览器来执行 wasm。wasm 相比 JS,拥有体积更小，执行更快，因为最终编译成二进制文件，所以一些安全策略代码也更适合 wasm。 经过尝试 C 和 Go 分别编写 WebAssembly，相较而言我认为 Go 无论从语言层面还是工具链，用起来都更加方便一些。 本文使用原生 go build，生成的 wasm 文件大约在1.4M左右，在生产环境中这个体积是很大的，优化 go 的 wasm 体积可以使用 tinygo 来 build，同样的代码使用 tinygo 构建之后约为22K，甚至比 C 语言构建 wasm 的体积还要小（C 语言 build 后约为44K，不同版本不同环境可能略有差异）。参考https://tinygo.org/\n本文介绍 Go WebAssembly 入门，前提已经安装 Go 1.11 及以上版本。 系列文章 Go WebAssembly 入门（二）\nGetting Started 编辑 main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, Go WebAssembly!\u0026#34;) } 把 main.","title":"Go-WebAssembly-入门（一）"},{"content":"简介 WatermelonDB 是 React Native 和 React Web 一种新的数据状态容器，虽然称作 DB 但意义和传统 DB 还是有些区别的，它的作用更像 Redux，同 Redux 类似，WatermelonDB 也是单一数据源原则，并且数据流单向的形式，UI 会根据记录的变化而相应的改变。 WatermelonDB 比 Redux 的优势在于，对于数据记录较大的 React 应用，能提供更好的性能表现。同时 WatermelonDB 也能比 Redux 更友好的管理数据流。\n示例 首先，定义 Models\nclass Post extends Model { @field(\u0026#39;name\u0026#39;) name @field(\u0026#39;body\u0026#39;) body @children(\u0026#39;comments\u0026#39;) comments } class Comment extends Model { @field(\u0026#39;body\u0026#39;) body @field(\u0026#39;author\u0026#39;) author } 然后 connect 数据到 components（和 Redux connect 比较像）\nconst Comment = ({ comment }) =\u0026gt; ( \u0026lt;View style={styles.commentBox}\u0026gt; \u0026lt;Text\u0026gt;{comment.body} — by {comment.author}\u0026lt;/Text\u0026gt; \u0026lt;/View\u0026gt; ) // This is how you make your app reactive! ✨ const enhance = withObservables([\u0026#39;comment\u0026#39;], ({ comment }) =\u0026gt; ({ comment: comment.observe() })) const EnhancedComment = enhance(Comment) render\nconst Post = ({ post, comments }) =\u0026gt; ( \u0026lt;View\u0026gt; \u0026lt;Text\u0026gt;{post.name}\u0026lt;/Text\u0026gt; \u0026lt;Text\u0026gt;Comments:\u0026lt;/Text\u0026gt; {comments.map(comment =\u0026gt; \u0026lt;Comment key={comment.id} comment={comment} /\u0026gt; )} \u0026lt;/View\u0026gt; ) const enhance = withObservables([\u0026#39;post\u0026#39;], ({ post }) =\u0026gt; ({ post: post.observe(), comments: post.comments.observe() })) 现在添加、更新、删除操作一条数据记录，绑定的 component 就会自动重新 render 了。 对于数据流大、应用复杂又比较追求性能的 React 应用，可以尝试一下 WatermelonDB 了。\n安装文档：https://github.com/Nozbe/WatermelonDB/blob/master/docs/Installation.md\n","permalink":"http://wlchn.github.io/posts/try-react-watermelondb/","summary":"简介 WatermelonDB 是 React Native 和 React Web 一种新的数据状态容器，虽然称作 DB 但意义和传统 DB 还是有些区别的，它的作用更像 Redux，同 Redux 类似，WatermelonDB 也是单一数据源原则，并且数据流单向的形式，UI 会根据记录的变化而相应的改变。 WatermelonDB 比 Redux 的优势在于，对于数据记录较大的 React 应用，能提供更好的性能表现。同时 WatermelonDB 也能比 Redux 更友好的管理数据流。\n示例 首先，定义 Models\nclass Post extends Model { @field(\u0026#39;name\u0026#39;) name @field(\u0026#39;body\u0026#39;) body @children(\u0026#39;comments\u0026#39;) comments } class Comment extends Model { @field(\u0026#39;body\u0026#39;) body @field(\u0026#39;author\u0026#39;) author } 然后 connect 数据到 components（和 Redux connect 比较像）\nconst Comment = ({ comment }) =\u0026gt; ( \u0026lt;View style={styles.commentBox}\u0026gt; \u0026lt;Text\u0026gt;{comment.","title":"高性能React数据容器WatermelonDB"},{"content":"MacBook Pro 的 touch bar 上的 esc 体验很差，尤其在频繁使用 vim 的时候，esc 不能给任何反馈，用着很不舒服。下面介绍两种方式用其它按键映射 esc(escape).\n方法一 通过 Mac 自带方式 System Preferences - Keyboard - Modifier Keys 通过上面操作可以修改其它按键为 escape 按键。 此方法的缺点是不太灵活，例如选择将 option 改为 escape 时，不能选择左右，变更为 escape 后，则不能使用 option。\n方法二 使用 Karabiner(KeyRemap4MacBook) 下载链接： https://pqrs.org/osx/karabiner/ 将“右 option”改为“escape”(如图)，这样使用 escape(右 option)的同时，还保留了 option(左)自身的功能。 ","permalink":"http://wlchn.github.io/posts/mac-change-esc/","summary":"MacBook Pro 的 touch bar 上的 esc 体验很差，尤其在频繁使用 vim 的时候，esc 不能给任何反馈，用着很不舒服。下面介绍两种方式用其它按键映射 esc(escape).\n方法一 通过 Mac 自带方式 System Preferences - Keyboard - Modifier Keys 通过上面操作可以修改其它按键为 escape 按键。 此方法的缺点是不太灵活，例如选择将 option 改为 escape 时，不能选择左右，变更为 escape 后，则不能使用 option。\n方法二 使用 Karabiner(KeyRemap4MacBook) 下载链接： https://pqrs.org/osx/karabiner/ 将“右 option”改为“escape”(如图)，这样使用 escape(右 option)的同时，还保留了 option(左)自身的功能。 ","title":"Mac修改esc键位映射"},{"content":"RSA 主要用法 公钥加密(encrypt)，私钥解密(decrypt) 私钥签名(sign)，公钥验证(verify) 网上讲述 RSA 原理的文字很多，很少涉及签名验证的实现。 第一种比较常见，本文主要是第二种方法的实现(JavaScript, Ruby, Golang)。 本文的 signature 最终结果都为 hex。\nJavaScript sign\nimport { KJUR } from \u0026#39;jsrsasign\u0026#39; const msg = \u0026#34;hello world\u0026#34; const privateKey = \u0026#34;-----BEGIN RSA PRIVATE KEY-----(your private key)\u0026#34; const sig = new KJUR.crypto.Signature({ \u0026#34;alg\u0026#34;: \u0026#34;SHA256withRSA\u0026#34; }); sig.init(privateKey); sig.updateString(msg) const signatureHex = sig.sign() verify\nconst publicKey = \u0026#34;-----BEGIN PUBLIC KEY-----(your public key)\u0026#34; const sig2 = new KJUR.crypto.Signature({\u0026#34;alg\u0026#34;: \u0026#34;SHA256withRSA\u0026#34;}); sig2.init(publicKey); sig2.updateString(msg) const isValid = sig2.verify(signatureHex) Ruby sign\nprivate_key = \u0026#34;-----BEGIN RSA PRIVATE KEY-----(your private key)\u0026#34; msg = \u0026#34;hello world\u0026#34; digest = OpenSSL::Digest::SHA256.new pkey = OpenSSL::PKey::RSA.new(private_key) signature = pkey.sign(digest, msg) hex_signature = signature.unpack(\u0026#39;H*\u0026#39;).first verify\npublic_key = \u0026#34;-----BEGIN PUBLIC KEY-----(your public key)\u0026#34; msg = \u0026#34;hello world\u0026#34; digest = OpenSSL::Digest::SHA256.new pkey = OpenSSL::PKey::RSA.new(public_key) pub_key = pkey.public_key puts pub_key.verify(digest, signature, msg) Golang sign\nimport ( \u0026#34;io\u0026#34; \u0026#34;crypto/rand\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;crypto/sha256\u0026#34; \u0026#34;crypto/rsa\u0026#34; \u0026#34;encoding/pem\u0026#34; ) msg := \u0026#34;hello world\u0026#34; rng := rand.Reader message := []byte(msg) hashed := sha256.Sum256(message) signature, err := rsa.SignPKCS1v15(rng, privateKey, crypto.SHA256, hashed[:]) signatureHex := hex.EncodeToString(signature) verify\nmsg := \u0026#34;hello world\u0026#34; sig, err := hex.DecodeString(signatureHex) if err != nil { fmt.Printf( \u0026#34;err hex signature: %s\\n\u0026#34;, err) return false } hashed := sha256.Sum256([]byte(msg)) err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hashed[:], sig) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;verify failed: %s\\n\u0026#34;, err) return false } return true ","permalink":"http://wlchn.github.io/posts/rsa-sha256-sign-verify-javascript-ruby-golang/","summary":"RSA 主要用法 公钥加密(encrypt)，私钥解密(decrypt) 私钥签名(sign)，公钥验证(verify) 网上讲述 RSA 原理的文字很多，很少涉及签名验证的实现。 第一种比较常见，本文主要是第二种方法的实现(JavaScript, Ruby, Golang)。 本文的 signature 最终结果都为 hex。\nJavaScript sign\nimport { KJUR } from \u0026#39;jsrsasign\u0026#39; const msg = \u0026#34;hello world\u0026#34; const privateKey = \u0026#34;-----BEGIN RSA PRIVATE KEY-----(your private key)\u0026#34; const sig = new KJUR.crypto.Signature({ \u0026#34;alg\u0026#34;: \u0026#34;SHA256withRSA\u0026#34; }); sig.init(privateKey); sig.updateString(msg) const signatureHex = sig.sign() verify\nconst publicKey = \u0026#34;-----BEGIN PUBLIC KEY-----(your public key)\u0026#34; const sig2 = new KJUR.crypto.Signature({\u0026#34;alg\u0026#34;: \u0026#34;SHA256withRSA\u0026#34;}); sig2.init(publicKey); sig2.updateString(msg) const isValid = sig2.","title":"RSA-SHA256-非对称签名与验证-sign-verify----JavaScript,-Ruby,-Golang"},{"content":"不做验证的代理（不安全、可内网使用） nginx 的用户 www-data 在组 www-data 中，而 docker.sock 的用户在 docker 组中，所以需要将 www-data 添加到 docker 组中\nsudo usermod -a -G www-data,docker www-data 查看用户以及组\ncompgen -u compgen -g nginx 的配置\nserver { listen 23750; location / { proxy_pass http://unix:/var/run/docker.sock:/; } } 重启 nginx 即可。\n做验证的代理（外网暴露安全） 按照https://docs.docker.com/engine/security/https/#create-a-ca-server-and-client-keys-with-openssl生成ca证书以及RSA证书\nca-key.pem ca.pem cert.pem key.pem server-cert.pem server-key.pem 配置 nginx 证书，ssl_verify_client 与 ssl_client_certificate 实现验证客户端，如客户端没有自签私钥则不能访问。\nserver { listen 23760; ssl on; ssl_certificate /home/deployer/docker-ca/server-cert.pem; ssl_certificate_key /home/deployer/docker-ca/server-key.pem; ssl_client_certificate /home/deployer/docker-ca/ca.pem; ssl_verify_client on; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 SSLv3; ssl_ciphers HIGH:!aNULL:!MD5; location = / { return 502 \u0026#39;\u0026#39;; } location / { proxy_pass http://unix:/var/run/docker.sock:/; } } 重启 nginx。 在客户端中加入证书验证。\nDocker.options = { client_cert: File.join(cert_path, \u0026#39;cert.pem\u0026#39;), client_key: File.join(cert_path, \u0026#39;key.pem\u0026#39;), ssl_ca_file: File.join(cert_path, \u0026#39;ca.pem\u0026#39;), scheme: \u0026#39;https\u0026#39;, } 即可做验证访问。\nAttach docker websocket server { listen 443; server_name docker-attach.wanglei.io; ssl on; ssl_certificate /home/deployer/docker-ca/wanglei.io.pem; ssl_certificate_key /home/deployer/docker-ca/wanglei.io.key; location / { return 400; } location ~ws/?$ { if ( $query_string !~ \u0026#34;secret=xxxxxxxx\u0026#34; ) { return 400; } proxy_pass http://unix:/var/run/docker.sock; proxy_http_version 1.1; proxy_set_header Upgrade \u0026#34;websocket\u0026#34;; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; } } ","permalink":"http://wlchn.github.io/posts/ssl-nginx-proxy-docker/","summary":"不做验证的代理（不安全、可内网使用） nginx 的用户 www-data 在组 www-data 中，而 docker.sock 的用户在 docker 组中，所以需要将 www-data 添加到 docker 组中\nsudo usermod -a -G www-data,docker www-data 查看用户以及组\ncompgen -u compgen -g nginx 的配置\nserver { listen 23750; location / { proxy_pass http://unix:/var/run/docker.sock:/; } } 重启 nginx 即可。\n做验证的代理（外网暴露安全） 按照https://docs.docker.com/engine/security/https/#create-a-ca-server-and-client-keys-with-openssl生成ca证书以及RSA证书\nca-key.pem ca.pem cert.pem key.pem server-cert.pem server-key.pem 配置 nginx 证书，ssl_verify_client 与 ssl_client_certificate 实现验证客户端，如客户端没有自签私钥则不能访问。\nserver { listen 23760; ssl on; ssl_certificate /home/deployer/docker-ca/server-cert.pem; ssl_certificate_key /home/deployer/docker-ca/server-key.pem; ssl_client_certificate /home/deployer/docker-ca/ca.pem; ssl_verify_client on; ssl_protocols TLSv1 TLSv1.","title":"SSL双向验证-Nginx反向代理docker-sock"}]